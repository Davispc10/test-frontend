import styles from '../styles/pages/Home.module.css'
import Head from 'next/head'

import { MdNavigateNext, MdNavigateBefore } from 'react-icons/md'
import { BsSearch } from "react-icons/bs";
import { ImSpinner2 } from "react-icons/im";

import { useState, useContext, useMemo, ChangeEvent, } from 'react'
import { ContextCharacter } from '@/context/OffSetPageContext';

import { CardCharacter } from '@/components/CardCharacter'
import { API } from '@/services/api'
import { useQuery } from '@tanstack/react-query'

export interface DataProps {
  data: {
    total: number;
    results: ResultsProps[]
  }
}

export interface ResultsProps {
  id: number;
  name: string;
  description: string;
  thumbnail: {
    path: string;
    extension: string;
  },
  resourceURI: string;
}

export default function Home() {
  const { offsetPage, setOffsetPage } = useContext(ContextCharacter)
  const [limitCharacterPage, setLimitCharacterPage] = useState<number>(20);
  const [characterName, setCharacterName] = useState<string>("");

  const querySearchPages = `&limit=${limitCharacterPage}&offset=${offsetPage}&`;
  const querySearchCharacter = `nameStartsWith=${characterName}&`;

  // the function will fetch all the characters
  async function getCharacters() {
    try {
      const response = await API.get(`${process.env.NEXT_PUBLIC_MARVEL_COMPLEMENT}${process.env.NEXT_PUBLIC_MARVEL_PUBLIC_KEY}${querySearchPages}${process.env.NEXT_PUBLIC_MARVEL_PRIVATE_KEY}`)
      return response.data
    } catch (error) {
      console.log(error);
    }
  }

  //the function will fetch the characters typed in the input
  async function searchCharacterByInput() {
    try {
      const response = await API.get(`${process.env.NEXT_PUBLIC_MARVEL_COMPLEMENT}${process.env.NEXT_PUBLIC_MARVEL_PUBLIC_KEY}${querySearchPages}${querySearchCharacter}${process.env.NEXT_PUBLIC_MARVEL_PRIVATE_KEY}`)
      return response.data
    } catch (error) {
      console.log(error);
    }
  }

  const { data, isLoading, isError } = useQuery<DataProps>({
    queryKey: ["characters", limitCharacterPage, offsetPage, characterName],
    queryFn: characterName ? searchCharacterByInput : getCharacters,
  })

  interface SearchByCharactersEvent extends React.FormEvent<HTMLFormElement> {
    target: HTMLFormElement & {
      name: {
        value: string;
      };
    };
  }

  // when clicking on the button, it will set the value typed in the input and send the data to characterName
  function handleSubmit(event: SearchByCharactersEvent) {
    event.preventDefault();

    setCharacterName(event.target.name.value);
    setOffsetPage(0);
  }

  function handleInput(event: ChangeEvent<HTMLInputElement>) {
    if (event.target.value == "") {
      setCharacterName(event.target.value)
    }
  }

  // This function will advance one page
  function nextPage() {
    if (data && data.data.total > limitCharacterPage) {
      setOffsetPage(previousState => Math.min((previousState + limitCharacterPage), data?.data.total - limitCharacterPage));
    }
  }

  // This function will go back one page
  function previousPage() {
    setOffsetPage(previousState => Math.max((previousState - limitCharacterPage), 0));
  }

  // checks if it has data and returns the current number of pages
  const currentPage = useMemo(() => {
    if (data?.data.total) {
      const currentPage = String((offsetPage / limitCharacterPage + 1).toFixed(0)).padStart(2, "0")
      return currentPage
    }
  }, [data?.data.total, offsetPage, limitCharacterPage]);

  // checks if it has data and returns the total number of pages
  const totalPages = useMemo(() => {
    if (data) {
      const totalPages = String((data?.data?.total / limitCharacterPage).toFixed(0)).padStart(2, "0")
      return totalPages
    }
  }, [data?.data.total, offsetPage, limitCharacterPage]);

  return (
    <>
      <Head>
        <title>Marvel Character</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <form onSubmit={handleSubmit}>
        <div className={styles.containerInput}>
          <input
            className={styles.inputCharacter}
            type="text"
            name="name"
            onChange={handleInput}
            placeholder='Digite o nome do personagem'
          />
          <button className={styles.buttonSearch}>
            <BsSearch className={styles.iconSearchCharacter} />
          </button>
        </div>
      </form>

      <section className={styles.navigatePage}>
        <button className={styles.buttonNavigate}>
          <MdNavigateBefore className={offsetPage < 1 ? styles.disabledButton : styles.navigateIcon} onClick={previousPage} />
        </button>

        {data?.data.total ? <div className={styles.showPages}>{currentPage}/{totalPages}</div> : ""}
        {!data && <span className={styles.loadingTotalPages}>Loading...</span>}

        <button className={styles.buttonNavigate}>
          <MdNavigateNext className={data && (offsetPage >= data?.data.total - limitCharacterPage) ? styles.disabledButton : styles.navigateIcon} onClick={() => nextPage()} />
        </button>
      </section>

      {isLoading && <p><ImSpinner2 className={styles.spinner} /></p>}
      {isError && <span className={styles.error}>Ops, algo deu errado!</span>}

      <div className={styles.mainContainer}>
        {data?.data?.results && data?.data?.results.length > 0 ?
          data?.data.results.map(result => {
            return (
              <CardCharacter key={result.id} result={result} />
            )
          }) : <p className={styles.characterNotFound}>Character not found, please try again.</p>
        }
      </div>
    </>
  )
}